import type { Query } from '@directus/types';
import type { FieldKey } from '../types.js';
import { flattenFilter } from './flatten-filter.js';

/**
 * Converts the passed Query object into a Set of path arrays, for example:
 *
 * ```
 * Set {
 * 	['author', 'age'],
 * 	['category']
 * }
 * ```
 */
export function extractPathsFromQuery(query: Query) {
	/**
	 * All nested paths used in the current query scope.
	 * This is generated by flattening the filters and adding in the used sort/aggregate fields.
	 */
	const paths: Set<FieldKey[]> = new Set();

	if (query.filter) {
		flattenFilter(paths, query.filter);
	}

	if (query.sort) {
		for (const field of query.sort) {
			// Sort can have dot notation fields for sorting on m2o values Sort fields can start with
			// `-` to indicate descending order, which should be dropped for permissions checks
			paths.add(field.split('.').map((field) => (field.startsWith('-') ? field.substring(1) : field)));
		}
	}

	if (query.aggregate) {
		for (const fields of Object.values(query.aggregate)) {
			for (const field of fields) {
				// Aggregate doesn't currently support aggregating on nested fields, but it doesn't hurt
				// to standardize it in the validation layer
				paths.add(field.split('.'));
			}
		}
	}

	if (query.group) {
		for (const field of query.group) {
			// Grouping doesn't currently support grouping on nested fields, but it doesn't hurt to
			// standardize it in the validation layer
			paths.add(field.split('.'));
		}
	}

	return paths;
}
